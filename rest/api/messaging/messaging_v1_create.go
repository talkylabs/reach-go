/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 * 
 * Reach Messaging API
 * Reach SMS API helps you add robust messaging capabilities to your applications.  Using this REST API, you can * send SMS messages * track the delivery of sent messages * schedule SMS messages to send at a later time * retrieve and modify message history
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"

    "time"
)


// Optional parameters for the method 'SendMessage'
type SendMessageParams struct {
    // The destination phone number in E.164 format of the message.
    Dest *string `json:"dest,omitempty"`
    // The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message.
    Src *string `json:"src,omitempty"`
    // The text of the message to send. It can be up to 1,600 GSM-7 characters in length. That limit varies if your message is not made of only GSM-7 characters. More generally, the message body should not exceed 10 segments.
    Body *string `json:"body,omitempty"`
    // The identifier of the bulk operation this message belongs to.
    BulkIdentifier *string `json:"bulkIdentifier,omitempty"`
    // The datetime at which the message will be sent. Must be in ISO 8601 format. A message must be scheduled at least 15 min in advance of message send time and cannot be scheduled more than 5 days in advance of the request.
    ScheduledTime *time.Time `json:"scheduledTime,omitempty"`
    // The URL that will be called to send status information of your message. If provided, the API POST these message status changes to the URL: `queued`, `failed`, `sent`, `canceled`, `delivered`, or `undelivered`. URLs must contain a valid hostname and underscores are not allowed. 
    StatusCallback *string `json:"statusCallback,omitempty"`
    // The maximum total price in the applet currency that should be paid for the message to be delivered. If the cost exceeds `maxPrice`, the message will fail and a status of `failed` is sent to the status callback. 
    MaxPrice *float32 `json:"maxPrice,omitempty"`
    // It represents how long, in seconds, the message can remain in the queue. After this period elapses, the message fails and the status callback is called. After a message has been accepted by a carrier, however, there is no guarantee that the message will not be queued after this period. It is recommended that this value be at least 5 seconds. The maximum allowed value is 14,400 which corresponds to 4 hours. 
    ValidityPeriod *int `json:"validityPeriod,omitempty"`
}

func (params *SendMessageParams) SetDest(Dest string) (*SendMessageParams){
    params.Dest = &Dest
    return params
}
func (params *SendMessageParams) SetSrc(Src string) (*SendMessageParams){
    params.Src = &Src
    return params
}
func (params *SendMessageParams) SetBody(Body string) (*SendMessageParams){
    params.Body = &Body
    return params
}
func (params *SendMessageParams) SetBulkIdentifier(BulkIdentifier string) (*SendMessageParams){
    params.BulkIdentifier = &BulkIdentifier
    return params
}
func (params *SendMessageParams) SetScheduledTime(ScheduledTime time.Time) (*SendMessageParams){
    params.ScheduledTime = &ScheduledTime
    return params
}
func (params *SendMessageParams) SetStatusCallback(StatusCallback string) (*SendMessageParams){
    params.StatusCallback = &StatusCallback
    return params
}
func (params *SendMessageParams) SetMaxPrice(MaxPrice float32) (*SendMessageParams){
    params.MaxPrice = &MaxPrice
    return params
}
func (params *SendMessageParams) SetValidityPeriod(ValidityPeriod int) (*SendMessageParams){
    params.ValidityPeriod = &ValidityPeriod
    return params
}

// This operation allows to send or schedule a message.  When sending a new message via the API, you must include the `dest` parameter.          This value should be the destination phone number. You must also include the `body` parameter containing the message's content as well as the `src` parameter   containing the sender alphanumeric Id or number.  To schedule a message, you must additionally pass the following parameter:  * `scheduledTime`: the date and time at which the sms will be sent in the ISO-8601 format. 
func (c *ApiService) SendMessage(params *SendMessageParams) (*MessageItem, error) {
    path := "/rest/messaging/v1/create"
    
data := url.Values{}
headers := make(map[string]interface{})

if params != nil && params.Dest != nil {
    data.Set("dest", *params.Dest)
}
if params != nil && params.Src != nil {
    data.Set("src", *params.Src)
}
if params != nil && params.Body != nil {
    data.Set("body", *params.Body)
}
if params != nil && params.BulkIdentifier != nil {
    data.Set("bulkIdentifier", *params.BulkIdentifier)
}
if params != nil && params.ScheduledTime != nil {
    data.Set("scheduledTime", fmt.Sprint((*params.ScheduledTime).Format(time.RFC3339)))
}
if params != nil && params.StatusCallback != nil {
    data.Set("statusCallback", *params.StatusCallback)
}
if params != nil && params.MaxPrice != nil {
    data.Set("maxPrice", fmt.Sprint(*params.MaxPrice))
}
if params != nil && params.ValidityPeriod != nil {
    data.Set("validityPeriod", fmt.Sprint(*params.ValidityPeriod))
}



    resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
    if err != nil {
        return nil, err
    }

    defer resp.Body.Close()

    ps := &MessageItem{}
    if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
        return nil, err
    }

    return ps, err
}
