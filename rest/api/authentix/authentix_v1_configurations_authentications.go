/*
 * This code was generated by
 *  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
 * | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
 * |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
 * |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
 * 
 * Reach Authentix API
 *  Reach Authentix API helps you easily integrate user authentification in your application. The authentification allows to verify that a user is indeed at the origin of a request from your application.  At the moment, the Reach Authentix API supports the following channels:    * SMS      * Email   We are continuously working to add additionnal channels. ## Base URL All endpoints described in this documentation are relative to the following base URL: ``` https://api.reach.talkylabs.com/rest/authentix/v1/ ```  The API is provided over HTTPS protocol to ensure data privacy.  ## API Authentication Requests made to the API must be authenticated. You need to provide the `ApiUser` and `ApiKey` associated with your applet. This information could be found in the settings of the applet. ```curl curl -X GET [BASE_URL]/configurations -H \"ApiUser:[Your_Api_User]\" -H \"ApiKey:[Your_Api_Key]\" ``` ## Reach Authentix API Workflow Three steps are needed in order to authenticate a given user using the Reach Authentix API. ### Step 1: Create an Authentix configuration A configuration is a set of settings used to define and send an authentication code to a user. This includes, for example: ```   - the length of the authentication code,    - the message template,    - and so on... ``` A configuaration could be created via the web application or directly using the Reach Authentix API. This step does not need to be performed every time one wants to use the Reach Authentix API. Indeed, once created, a configuartion could be used to authenticate several users in the future.    ### Step 2: Send an authentication code A configuration is used to send an authentication code via a selected channel to a user. For now, the supported channels are `sms`, and `email`. We are working hard to support additional channels. Newly created authentications will have a status of `awaiting`. ### Step 3: Verify the authentication code This step allows to verify that the code submitted by the user matched the one sent previously. If, there is a match, then the status of the authentication changes from `awaiting` to `passed`. Otherwise, the status remains `awaiting` until either it is verified or it expires. In the latter case, the status becomes `expired`. 
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

    "github.com/talkylabs/reach-go/client"
)


// This operation allows to fetch the API record associated to an authentication.   
func (c *ApiService) FetchAuthentication(ConfigurationId string, AuthenticationId string, ) (*AuthenticationItem, error) {
    path := "/rest/authentix/v1/configurations/{configurationId}/authentications/{authenticationId}"
        path = strings.Replace(path, "{"+"configurationId"+"}", ConfigurationId, -1)
    path = strings.Replace(path, "{"+"authenticationId"+"}", AuthenticationId, -1)

data := url.Values{}
headers := make(map[string]interface{})




    resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
    if err != nil {
        return nil, err
    }

    defer resp.Body.Close()

    ps := &AuthenticationItem{}
    if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
        return nil, err
    }

    return ps, err
}

// Optional parameters for the method 'ListAuthentications'
type ListAuthenticationsParams struct {
    // Maximum number of records to return per call.
    PageSize *int `json:"pageSize,omitempty"`
    // Max number of records to return.
    Limit *int `json:"limit,omitempty"`
}

func (params *ListAuthenticationsParams) SetPageSize(PageSize int) (*ListAuthenticationsParams){
    params.PageSize = &PageSize
    return params
}
func (params *ListAuthenticationsParams) SetLimit(Limit int) (*ListAuthenticationsParams){
    params.Limit = &Limit
    return params
}

// Retrieve a single page of Authentications records from the API. Request is executed immediately.
func (c *ApiService) PageAuthentications(ConfigurationId string, params *ListAuthenticationsParams, pageNumber string) (*PaginatedAuthenticationItemList, error) {
    path := "/rest/authentix/v1/configurations/{configurationId}/authentications"

        path = strings.Replace(path, "{"+"configurationId"+"}", ConfigurationId, -1)

data := url.Values{}
headers := make(map[string]interface{})

if params != nil && params.PageSize != nil {
    data.Set("pageSize", fmt.Sprint(*params.PageSize))
}

    if pageNumber != "" {
        data.Set("page", pageNumber)
    }

    resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
    if err != nil {
        return nil, err
    }

    defer resp.Body.Close()

    ps := &PaginatedAuthenticationItemList{}
    if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
        return nil, err
    }

    return ps, err
}

// Lists Authentications records from the API as a list. Unlike stream, this operation is eager and loads 'limit' records into memory before returning.
func (c *ApiService) ListAuthentications(ConfigurationId string, params *ListAuthenticationsParams) ([]AuthenticationItem, error) {
	response, errors := c.StreamAuthentications(ConfigurationId, params)

	records := make([]AuthenticationItem, 0)
	for record := range response {
		records = append(records, record)
	}

	if err := <-errors; err != nil {
		return nil, err
	}

	return records, nil
}

// Streams Authentications records from the API as a channel stream. This operation lazily loads records as efficiently as possible until the limit is reached.
func (c *ApiService) StreamAuthentications(ConfigurationId string, params *ListAuthenticationsParams) (chan AuthenticationItem, chan error) {
	if params == nil {
		params = &ListAuthenticationsParams{}
	}
	params.SetPageSize(client.ReadLimits(params.PageSize, params.Limit))

	recordChannel := make(chan AuthenticationItem, 1)
	errorChannel := make(chan error, 1)

	response, err := c.PageAuthentications(ConfigurationId, params, "")
	if err != nil {
		errorChannel <- err
		close(recordChannel)
		close(errorChannel)
	} else {
		go c.streamAuthentications(ConfigurationId, response, params, recordChannel, errorChannel)
	}

	return recordChannel, errorChannel
}


func (c *ApiService) streamAuthentications(ConfigurationId string, response *PaginatedAuthenticationItemList, params *ListAuthenticationsParams, recordChannel chan AuthenticationItem, errorChannel chan error) {
	curRecord := 1
	
	path := "/rest/authentix/v1/configurations/{configurationId}/authentications"

        path = strings.Replace(path, "{"+"configurationId"+"}", ConfigurationId, -1)

data := url.Values{}

if params != nil && params.PageSize != nil {
    data.Set("pageSize", fmt.Sprint(*params.PageSize))
}

    
    baseURL, err0 := client.UrlWithoutPaginationInfo(c.baseURL+path, data)
    if err0 != nil {
		errorChannel <- err0
		return
	}

	for response != nil {
		responseRecords := response.Authentications
		for item := range responseRecords {
			recordChannel <- responseRecords[item]
			curRecord += 1
			if params.Limit != nil && *params.Limit < curRecord {
				close(recordChannel)
				close(errorChannel)
				return
			}
		}

		record, err := client.GetNext(baseURL, response, c.getNextPaginatedAuthenticationItemList)
		if err != nil {
			errorChannel <- err
			break
		} else if record == nil {
			break
		}

		response = record.(*PaginatedAuthenticationItemList)
	}

	close(recordChannel)
	close(errorChannel)
}

func (c *ApiService) getNextPaginatedAuthenticationItemList(nextPageUrl string) (interface{}, error) {
    if nextPageUrl == "" {
        return nil, nil
    }
    resp, err := c.requestHandler.Get(nextPageUrl, nil, nil)
    if err != nil {
        return nil, err
    }

    defer resp.Body.Close()

    ps := &PaginatedAuthenticationItemList{}
    if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
        return nil, err
    }
    return ps, nil
}


// Optional parameters for the method 'StartAuthentication'
type StartAuthenticationParams struct {
    // The phone number or email where to send the authentication code. Phone numbers must be in E.164 format.
    Dest *string `json:"dest,omitempty"`
    // The channel by which the authentication code is sent.
    Channel *string `json:"channel,omitempty"`
    // a service name overwriting the one defined in the configuration.
    ServiceName *string `json:"serviceName,omitempty"`
    // the pre-generated code to be sent. Its length should be between 4 and 10 inclusive.
    CustomCode *string `json:"customCode,omitempty"`
    // Information related to the digital payment to authenticate. It is required when `usedForDigitalPayment` is true. It is ignored otherwise. It is a stringfied JSON map where keys are `payee`, `amount`, and `currency` and the associated values are respectively the payee, the amount, and the currency of a financial transaction. 
    PaymentInfo *string `json:"paymentInfo,omitempty"`
    // This is the ID of the message template to use for sending the authenetication code. It could be an sms or email template depending on the channel being used. It overwirites the template ID defined in the configuration if any. 
    TemplateId *string `json:"templateId,omitempty"`
    // A stringfied JSON map where keys are message template parameters and the values are the parameter values to be used when sending the authentication code. It may also be used to provide additional parameters for sending email based authentications such as the email used for sending the code.
    TemplateDataMap *string `json:"templateDataMap,omitempty"`
}

func (params *StartAuthenticationParams) SetDest(Dest string) (*StartAuthenticationParams){
    params.Dest = &Dest
    return params
}
func (params *StartAuthenticationParams) SetChannel(Channel string) (*StartAuthenticationParams){
    params.Channel = &Channel
    return params
}
func (params *StartAuthenticationParams) SetServiceName(ServiceName string) (*StartAuthenticationParams){
    params.ServiceName = &ServiceName
    return params
}
func (params *StartAuthenticationParams) SetCustomCode(CustomCode string) (*StartAuthenticationParams){
    params.CustomCode = &CustomCode
    return params
}
func (params *StartAuthenticationParams) SetPaymentInfo(PaymentInfo string) (*StartAuthenticationParams){
    params.PaymentInfo = &PaymentInfo
    return params
}
func (params *StartAuthenticationParams) SetTemplateId(TemplateId string) (*StartAuthenticationParams){
    params.TemplateId = &TemplateId
    return params
}
func (params *StartAuthenticationParams) SetTemplateDataMap(TemplateDataMap string) (*StartAuthenticationParams){
    params.TemplateDataMap = &TemplateDataMap
    return params
}

// This operation allows to start a new authentication process by sending a code via a specific channel. 
func (c *ApiService) StartAuthentication(ConfigurationId string, params *StartAuthenticationParams) (*AuthenticationItem, error) {
    path := "/rest/authentix/v1/configurations/{configurationId}/authentications"
        path = strings.Replace(path, "{"+"configurationId"+"}", ConfigurationId, -1)

data := url.Values{}
headers := make(map[string]interface{})

if params != nil && params.Dest != nil {
    data.Set("dest", *params.Dest)
}
if params != nil && params.Channel != nil {
    data.Set("channel", *params.Channel)
}
if params != nil && params.ServiceName != nil {
    data.Set("serviceName", *params.ServiceName)
}
if params != nil && params.CustomCode != nil {
    data.Set("customCode", *params.CustomCode)
}
if params != nil && params.PaymentInfo != nil {
    data.Set("paymentInfo", *params.PaymentInfo)
}
if params != nil && params.TemplateId != nil {
    data.Set("templateId", *params.TemplateId)
}
if params != nil && params.TemplateDataMap != nil {
    data.Set("templateDataMap", *params.TemplateDataMap)
}



    resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
    if err != nil {
        return nil, err
    }

    defer resp.Body.Close()

    ps := &AuthenticationItem{}
    if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
        return nil, err
    }

    return ps, err
}

// Optional parameters for the method 'UpdateAuthenticationStatus'
type UpdateAuthenticationStatusParams struct {
    // The new status of the authentication.
    Status *string `json:"status,omitempty"`
}

func (params *UpdateAuthenticationStatusParams) SetStatus(Status string) (*UpdateAuthenticationStatusParams){
    params.Status = &Status
    return params
}

// This operation allows to manually update the status of an authentication. This should only be used with custom code authentications.  Set the authentication status to \"passed\" after you validated the authentication code. Similarly, set the authentication status to \"canceled\" if you want to restart start a new authentication with a different code.  When not using custom codes, there is no need to used this method as the REACH Authentix API can manage the whole life cycle of an authentication. 
func (c *ApiService) UpdateAuthenticationStatus(ConfigurationId string, AuthenticationId string, params *UpdateAuthenticationStatusParams) (*AuthenticationItem, error) {
    path := "/rest/authentix/v1/configurations/{configurationId}/authentications/{authenticationId}"
        path = strings.Replace(path, "{"+"configurationId"+"}", ConfigurationId, -1)
    path = strings.Replace(path, "{"+"authenticationId"+"}", AuthenticationId, -1)

data := url.Values{}
headers := make(map[string]interface{})

if params != nil && params.Status != nil {
    data.Set("status", *params.Status)
}



    resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
    if err != nil {
        return nil, err
    }

    defer resp.Body.Close()

    ps := &AuthenticationItem{}
    if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
        return nil, err
    }

    return ps, err
}
